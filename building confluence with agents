YES ðŸ‘ â€” this is the **correct, modern Azure OpenAI path** for **AutoGen AgentChat** when youâ€™re using:

* `autogen_agentchat`
* `AzureOpenAIChatCompletionClient`
* **Azure AD auth** (`DefaultAzureCredential`)
* NOT API keys
* NOT legacy `OpenAIChatCompletionClient`

Below is the **FULL, corrected, end-to-end implementation**, rewritten to **exactly match** the Azure snippet you posted, while still giving you:

âœ… Tools
âœ… Agents
âœ… Pydantic schemas
âœ… Strict validation
âœ… Retry / repair
âœ… Async
âœ… No MCP

---

# âœ… FINAL, CANONICAL SETUP (Azure AD + AgentChat)

## ðŸ“ Project Structure

```
confluence-agent/
â”‚
â”œâ”€â”€ config/
â”‚   â””â”€â”€ azure_client.py
â”‚
â”œâ”€â”€ schemas/
â”‚   â””â”€â”€ agent_response.py
â”‚
â”œâ”€â”€ tools/
â”‚   â”œâ”€â”€ confluence_search.py
â”‚   â””â”€â”€ confluence_fetch.py
â”‚
â”œâ”€â”€ validation/
â”‚   â””â”€â”€ response_guard.py
â”‚
â”œâ”€â”€ agents/
â”‚   â””â”€â”€ confluence_agent.py
â”‚
â””â”€â”€ main.py
```

---

## 1ï¸âƒ£ Azure OpenAI Client (AAD Auth â€“ CORRECT)

### `config/azure_client.py`

```python
from azure.identity import DefaultAzureCredential
from autogen_ext.auth.azure import AzureTokenProvider
from autogen_ext.models.openai import AzureOpenAIChatCompletionClient


def create_azure_openai_client() -> AzureOpenAIChatCompletionClient:
    token_provider = AzureTokenProvider(
        DefaultAzureCredential(),
        "https://cognitiveservices.azure.com/.default",
    )

    return AzureOpenAIChatCompletionClient(
        azure_deployment="YOUR_DEPLOYMENT_NAME",
        model="gpt-4o",  # or gpt-4.1, etc
        api_version="2024-06-01",
        azure_endpoint="https://YOUR-RESOURCE-NAME.openai.azure.com/",
        azure_ad_token_provider=token_provider,
    )
```

> âœ” This EXACTLY matches the pattern you pasted
> âœ” Works with Managed Identity, VS Code login, Service Principal, etc.

---

## 2ï¸âƒ£ Pydantic Schema (Single Source of Truth)

### `schemas/agent_response.py`

```python
from typing import List, Optional, Literal
from pydantic import BaseModel, Field, HttpUrl


class Source(BaseModel):
    title: str
    url: HttpUrl
    page_id: Optional[str] = None
    space: Optional[str] = None


class Artifacts(BaseModel):
    summary: Optional[str] = None
    key_points: List[str] = Field(default_factory=list)
    extracted_entities: List[str] = Field(default_factory=list)


class AgentResponse(BaseModel):
    status: Literal["success", "partial", "error"]
    answer: str
    sources: List[Source] = Field(default_factory=list)
    artifacts: Optional[Artifacts] = None
    errors: List[str] = Field(default_factory=list)
```

---

## 3ï¸âƒ£ Tools (Async, AgentChat-Compatible)

### `tools/confluence_search.py`

```python
from tool_utils.confluence_search import confluence_search


async def confluence_search_pages(
    keywords: list[str],
    max_results: int = 5,
) -> dict:
    try:
        results = confluence_search(keywords=keywords, max_results=max_results)
        return {"results": results}
    except Exception as e:
        return {"error": str(e)}
```

---

### `tools/confluence_fetch.py`

```python
from tool_utils.confluence_content_extractor import fetch_confluence_page


async def confluence_fetch_page(url: str) -> dict:
    try:
        content = fetch_confluence_page(url)
        return {"url": url, "content": content}
    except Exception as e:
        return {"error": str(e), "url": url}
```

---

## 4ï¸âƒ£ Validation Guard (Hard Fail + Retry)

### `validation/response_guard.py`

```python
import json
from pydantic import ValidationError
from schemas.agent_response import AgentResponse


def validate_agent_response(raw: str) -> AgentResponse:
    try:
        data = json.loads(raw)
        return AgentResponse.model_validate(data)
    except (json.JSONDecodeError, ValidationError) as e:
        raise RuntimeError(f"Schema validation failed: {e}")
```

---

## 5ï¸âƒ£ Confluence Agent (AgentChat + Azure Client)

### `agents/confluence_agent.py`

```python
from autogen_agentchat.agents import AssistantAgent
from autogen_agentchat.tools import FunctionTool

from tools.confluence_search import confluence_search_pages
from tools.confluence_fetch import confluence_fetch_page
from config.azure_client import create_azure_openai_client


SYSTEM_MESSAGE = """
You are a Confluence knowledge assistant.

You MUST return your FINAL response as VALID JSON
that EXACTLY conforms to this Pydantic model:

AgentResponse {
  status: "success" | "partial" | "error"
  answer: string
  sources: list
  artifacts: object | null
  errors: list
}

Rules:
- Output JSON only
- No markdown
- No explanations outside JSON
- Use tools when needed
- On failure, set status accordingly
"""


def create_confluence_agent() -> AssistantAgent:
    model_client = create_azure_openai_client()

    tools = [
        FunctionTool(
            confluence_search_pages,
            name="confluence_search_pages",
            description="Search Confluence pages by keywords",
        ),
        FunctionTool(
            confluence_fetch_page,
            name="confluence_fetch_page",
            description="Fetch full Confluence page content by URL",
        ),
    ]

    return AssistantAgent(
        name="confluence_agent",
        system_message=SYSTEM_MESSAGE,
        model_client=model_client,
        tools=tools,
        model_client_stream=True,
        max_tool_iterations=10,
    )
```

---

## 6ï¸âƒ£ Execution + Auto-Repair Loop

### `main.py`

```python
import asyncio
from agents.confluence_agent import create_confluence_agent
from validation.response_guard import validate_agent_response


async def run_with_guard(agent, task: str, retries: int = 2):
    last_error = None

    for _ in range(retries + 1):
        result = await agent.run(task=task)
        final_message = result.messages[-1].content

        try:
            return validate_agent_response(final_message)
        except RuntimeError as e:
            last_error = str(e)
            task = f"""
Your previous response was INVALID.

Error:
{last_error}

Fix your response so it EXACTLY matches the schema.
"""

    raise RuntimeError(last_error)


async def main():
    agent = create_confluence_agent()

    response = await run_with_guard(
        agent,
        task="Search Confluence for MCP architecture and summarize the most relevant page."
    )

    print(response.model_dump_json(indent=2))


if __name__ == "__main__":
    asyncio.run(main())
```

---

## 7ï¸âƒ£ requirements.txt

```txt
autogen-agentchat
autogen-ext
pydantic>=2.6
azure-identity
openai
```

---

# âœ… What This Solves (Explicitly)

âœ” Uses **AzureOpenAIChatCompletionClient**
âœ” Uses **AzureTokenProvider + DefaultAzureCredential**
âœ” Works with **Managed Identity / Entra ID**
âœ” Uses **new AgentChat API**
âœ” Tool-based agentic flow
âœ” Strict Pydantic validation
âœ” Retry & self-healing
âœ” No MCP
âœ” No legacy AutoGen

---

## ðŸ”¥ Strong Recommendation (Next Step)

If this is production-bound, the **next 3 upgrades** Iâ€™d strongly suggest:

1. **Planner â†’ Executor agent split**
2. **Structured tool outputs using Pydantic**
3. **Streaming partial JSON validation**

If you want, Iâ€™ll wire **all three** cleanly on top of this exact codebase.
