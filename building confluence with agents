Ahhh â€” this is a *great* question. Youâ€™re basically asking how to turn your setup from **â€œsearch with keywordsâ€** into a **proper agentic query planner**:

> **User intent â†’ structured understanding â†’ CQL generation â†’ tool execution**

This is exactly the right way to do Confluence search at scale.

Below Iâ€™ll give you a **clean, production-grade pattern** that fits perfectly into your current AutoGen + Azure OpenAI + Pydantic stack.

---

# ğŸ§  High-level Architecture

```
User Query (NL)
      â†“
Intent Identification Agent (LLM)
      â†“
Structured Intent (Pydantic)
      â†“
CQL Builder (deterministic)
      â†“
Confluence Search Tool (CQL)
      â†“
Result Normalization
      â†“
Final Answer Agent
```

Key idea:

* **LLM decides â€œwhatâ€**
* **Code decides â€œhowâ€**

---

# 1ï¸âƒ£ Define the Intent Schema (Pydantic)

### `schemas/search_intent.py`

```python
from typing import List, Optional, Literal
from pydantic import BaseModel, Field


class SearchIntent(BaseModel):
    intent_type: Literal[
        "search",
        "fetch_page",
        "list_recent",
        "unknown"
    ]

    keywords: List[str] = Field(default_factory=list)

    spaces: List[str] = Field(default_factory=list)

    author: Optional[str] = None

    labels: List[str] = Field(default_factory=list)

    created_after: Optional[str] = None  # ISO date
    updated_after: Optional[str] = None

    max_results: int = 5
```

This is **LLM output**, but **strongly constrained**.

---

# 2ï¸âƒ£ Intent Identification Agent

### System prompt (IMPORTANT)

```python
INTENT_SYSTEM_MESSAGE = """
You are an intent classification agent for Confluence search.

Your job:
- Analyze the user's request
- Extract structured search intent
- Return ONLY valid JSON matching the SearchIntent model

Rules:
- No markdown
- No explanations
- Output JSON only
- If unsure, set intent_type = "unknown"
"""
```

---

### `agents/intent_agent.py`

```python
import autogen
from config.azure_openai import AZURE_OPENAI_CONFIG

intent_agent = autogen.AssistantAgent(
    name="intent_agent",
    system_message=INTENT_SYSTEM_MESSAGE,
    llm_config=AZURE_OPENAI_CONFIG,
)
```

---

# 3ï¸âƒ£ Intent Parsing + Validation

### `validation/intent_guard.py`

```python
import json
from pydantic import ValidationError
from schemas.search_intent import SearchIntent


def parse_intent(raw: str) -> SearchIntent:
    try:
        data = json.loads(raw)
        return SearchIntent.model_validate(data)
    except (json.JSONDecodeError, ValidationError) as e:
        raise RuntimeError(f"Invalid intent output: {e}")
```

---

# 4ï¸âƒ£ Deterministic CQL Builder (NO LLM HERE)

### `cql/builder.py`

```python
from schemas.search_intent import SearchIntent


def build_cql(intent: SearchIntent) -> str:
    clauses = []

    if intent.keywords:
        text = " AND ".join(
            f'text ~ "{kw}"' for kw in intent.keywords
        )
        clauses.append(f"({text})")

    if intent.spaces:
        spaces = ", ".join(f'"{s}"' for s in intent.spaces)
        clauses.append(f"space IN ({spaces})")

    if intent.author:
        clauses.append(f'creator = "{intent.author}"')

    if intent.labels:
        labels = ", ".join(f'"{l}"' for l in intent.labels)
        clauses.append(f"label IN ({labels})")

    if intent.created_after:
        clauses.append(f'created > "{intent.created_after}"')

    if intent.updated_after:
        clauses.append(f'lastModified > "{intent.updated_after}"')

    if not clauses:
        return "type = page"

    return " AND ".join(clauses)
```

This guarantees:

* âœ… Safe CQL
* âœ… No prompt injection
* âœ… Deterministic output

---

# 5ï¸âƒ£ Update Search Tool to Accept CQL

### `tools/confluence_search.py`

```python
def confluence_search_cql(cql: str, max_results: int = 5) -> dict:
    try:
        results = confluence_search(
            cql=cql,
            max_results=max_results
        )
        return {"results": results}
    except Exception as e:
        return {
            "error": str(e),
            "cql": cql
        }
```

---

# 6ï¸âƒ£ Orchestrator (Planner â†’ Tool â†’ Responder)

### `agent/orchestrator.py`

```python
from validation.intent_guard import parse_intent
from cql.builder import build_cql


def run_intent_search(
    user_proxy,
    intent_agent,
    search_agent,
    user_query: str,
):
    # 1ï¸âƒ£ Identify intent
    intent_chat = user_proxy.initiate_chat(
        intent_agent,
        message=user_query
    )

    intent = parse_intent(intent_chat.summary)

    if intent.intent_type != "search":
        raise RuntimeError("Unsupported intent")

    # 2ï¸âƒ£ Build CQL
    cql = build_cql(intent)

    # 3ï¸âƒ£ Execute search via tool
    search_message = (
        f"Run a Confluence search using this CQL:\n{cql}\n"
        f"Max results: {intent.max_results}"
    )

    return user_proxy.initiate_chat(
        search_agent,
        message=search_message
    )
```

---

# 7ï¸âƒ£ Register the CQL Tool

```python
user_proxy.register_function(
    function_map={
        "confluence_search_cql": confluence_search_cql,
    }
)
```

---

# 8ï¸âƒ£ Example Flow

### User input:

> â€œFind recent design docs in ENG space authored by Aliceâ€

### Intent output:

```json
{
  "intent_type": "search",
  "keywords": ["design"],
  "spaces": ["ENG"],
  "author": "Alice",
  "labels": [],
  "created_after": null,
  "updated_after": null,
  "max_results": 5
}
```

### Generated CQL:

```sql
(text ~ "design") AND space IN ("ENG") AND creator = "Alice"
```

---

# ğŸ”¥ Why this design is *correct*

* LLM does **semantic reasoning**
* Code does **query construction**
* No hallucinated CQL
* Easy to test
* Easy to extend:

  * date ranges
  * content types
  * attachments
  * permissions

---

## Want to level this up further?

I can:

* Add **planner/executor agents**
* Add **CQL explanation & validation**
* Add **multi-intent routing**
* Add **confidence scoring**
* Add **LangGraph version**

Just say the word â€” youâ€™re building this the *right way*.







Perfect â€” thanks for sharing `main.py`.
Now we can be **very precise** and map the **intent â†’ CQL â†’ search tool** flow **directly onto *your* async/await AutoGen-style code**, without breaking your guard logic.

Iâ€™ll do this in three layers:

1. **What your current `main.py` is doing**
2. **What exactly needs to change (minimal diff)**
3. **Final corrected `main.py` with intent + CQL**

No abstractions, no rewrites.

---

## 1ï¸âƒ£ What your current `main.py` does (correctly)

Your flow right now is:

```text
task (string)
  â†“
agent.run(task)
  â†“
agent produces final JSON
  â†“
validate_agent_response()
  â†“
retry if invalid
```

This means:

* You have **one agent**
* That agent is doing **intent understanding + search + summarization**
* Validation happens at the very end

This is why:

* You *canâ€™t* cleanly insert intent â†’ CQL
* The LLM is still deciding *how* to search

---

## 2ï¸âƒ£ What needs to change (ONLY TWO THINGS)

### âœ… Add an **intent step before** `run_with_guard`

### âœ… Pass **CQL**, not raw user text, into the main agent

Everything else stays.

---

## 3ï¸âƒ£ Minimal Architecture Change (Mapped to YOUR Code)

### NEW flow (still async, still guarded):

```text
User task
  â†“
Intent Agent (LLM)
  â†“
SearchIntent (Pydantic)
  â†“
CQL Builder (Python)
  â†“
Main Agent (search + answer)
  â†“
validate_agent_response
```

---

## 4ï¸âƒ£ Concrete Code Changes

### ğŸ”¹ Step 1: Import intent pieces

At the top of `main.py` **add**:

```python
from agents.intent_agent import intent_agent
from validation.intent_guard import parse_intent
from cql.builder import build_cql
```

---

### ğŸ”¹ Step 2: Add intent + CQL orchestration

Add this helper **above** `main()`:

```python
async def run_intent_search(agent, user_task: str, retries: int = 2):
    # 1ï¸âƒ£ Identify intent
    intent_result = await intent_agent.run(task=user_task)
    intent_message = intent_result.messages[-1].content
    intent = parse_intent(intent_message)

    if intent.intent_type != "search":
        raise RuntimeError("Only search intent supported")

    # 2ï¸âƒ£ Build CQL
    cql = build_cql(intent)

    # 3ï¸âƒ£ Hand CQL to main agent
    search_task = f"""
Search Confluence using the following CQL:

{cql}

Return results and a summary.
"""

    return await run_with_guard(
        agent,
        task=search_task,
        retries=retries
    )
```

âš ï¸ **Important**
The main agent never sees the original user query â€” only **clean CQL**.

---

## 5ï¸âƒ£ Your Updated `main()` (VERY SMALL CHANGE)

### âŒ BEFORE

```python
response = await run_with_guard(
    agent,
    task="Search Confluence for HSBC productivity Suite and give me some information"
)
```

---

### âœ… AFTER (this is the key change)

```python
response = await run_intent_search(
    agent,
    user_task="Search Confluence for HSBC productivity Suite and give me some information"
)
```

Thatâ€™s it.
Your guard, retries, validation â€” all unchanged.

---

## 6ï¸âƒ£ Why this works with YOUR async agent

* `intent_agent.run()` â†’ async LLM call
* `parse_intent()` â†’ Pydantic validation
* `build_cql()` â†’ deterministic
* `run_with_guard()` â†’ unchanged retry logic

You now have **two LLM calls**:

1. Intent extraction
2. Final answer

This is correct and scalable.

---

## 7ï¸âƒ£ What your agent prompt should now say (IMPORTANT)

Your **main Confluence agent system message** should include:

```text
You will be given a Confluence CQL query.
DO NOT modify the query.
Use it exactly as provided to search Confluence.
```

This prevents the LLM from â€œimprovingâ€ CQL.

---

## 8ï¸âƒ£ Sanity Check (Example)

### User input:

```
"Find recent HSBC productivity suite documents"
```

### Intent Agent output:

```json
{
  "intent_type": "search",
  "keywords": ["HSBC", "productivity suite"],
  "spaces": [],
  "author": null,
  "labels": [],
  "max_results": 5
}
```

### Generated CQL:

```sql
(text ~ "HSBC" AND text ~ "productivity suite")
```

### Main agent task:

```
Search Confluence using the following CQL:
(text ~ "HSBC" AND text ~ "productivity suite")
```

---

## 9ï¸âƒ£ Why this is the *right* level of change

âœ… Minimal edits
âœ… No refactor of guard logic
âœ… No schema changes
âœ… Deterministic querying
âœ… Easy to add routing later

---

## If you want next (optional but powerful)

I can:

* Add **fetch_page intent**
* Add **clarification loop** if intent is ambiguous
* Add **confidence score to intent**
* Collapse this into **planner/executor agents**
* Convert this to **LangGraph**

If you want, paste `create_confluence_agent()` and Iâ€™ll adjust its system prompt exactly for this flow.
