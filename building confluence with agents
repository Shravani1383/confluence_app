Yes â€” absolutely ğŸ‘
And the good news is: **you do NOT need to rewrite your existing code**.
We can **merge the CQL-builder agent cleanly on top of what you already have**, with *small, safe, incremental changes*.

Below Iâ€™ll show you **exactly where to add what**, step by step, using **your current structure and patterns**.

---

## ğŸ”§ What we will add (minimal, clean merge)

We will add **three small things**:

1. âœ… A **new schema** (`CQLQuery`)
2. âœ… A **new agent factory** (`create_cql_builder_agent`)
3. âœ… A **new tool entrypoint** that accepts **raw CQL**
4. âœ… A **thin orchestrator** that connects both agents

Your existing:

* `confluence_agents.py`
* `response_guard.py`
* `confluence_search.py`

ğŸ‘‰ **remain intact**

---

## 1ï¸âƒ£ Add a new schema (drop-in)

ğŸ“ **`schemas/cql_query.py`** (new file)

```python
from pydantic import BaseModel
from typing import List, Optional

class CQLQuery(BaseModel):
    cql: str
    keywords: List[str]
    spaces: Optional[List[str]] = None
    content_types: List[str] = ["page"]
    limit: int = 10
```

No impact on existing schemas.

---

## 2ï¸âƒ£ Add CQL Builder Agent (merge into `confluence_agents.py`)

ğŸ“ **`confluence_agent/confluence_agents.py`**

Add this **below** your existing `create_confluence_agent()`.

```python
from schemas.cql_query import CQLQuery
import json

CQL_SYSTEM_MESSAGE = """
You are a Confluence CQL query builder.

Your task:
- Analyze the user's intent
- Extract important keywords
- Construct the BEST possible Confluence CQL query

Rules:
- Output ONLY valid JSON
- Do NOT execute searches
- Do NOT explain anything
- Prefer text ~ for fuzzy matching
- Use AND between required concepts
- Keep queries precise, not overly broad

Output must EXACTLY match this schema:

{
  "cql": string,
  "keywords": string[],
  "spaces": string[] | null,
  "content_types": string[],
  "limit": number
}
"""
```

Now add the factory:

```python
def create_cql_builder_agent() -> AssistantAgent:
    api_key = os.environ.get("AZURE_OPENAI_API_KEY") or gpt_4o_config.get("api_key")
    if not api_key:
        raise RuntimeError("Azure OpenAI API key not found")

    model_client = AzureOpenAIChatCompletionClient(
        azure_deployment=gpt_4o_config.get("deployment"),
        model=gpt_4o_config.get("model"),
        api_version=gpt_4o_config.get("api_version"),
        azure_endpoint=gpt_4o_config.get("api_base"),
        api_key=api_key,
        parallel_tool_calls=False,
    )

    return AssistantAgent(
        name="cql_builder_agent",
        system_message=CQL_SYSTEM_MESSAGE,
        model_client=model_client,
        tools=[],              # ğŸ”´ NO TOOLS
        model_client_stream=False,
        max_tool_iterations=0,
    )
```

âœ” Reuses your Azure config
âœ” Matches your agent style
âœ” Zero impact on existing agent

---

## 3ï¸âƒ£ Add CQL validation (reuse your guard style)

ğŸ“ **`validation/response_guard.py`**

Add this **below your existing validators**:

```python
from schemas.cql_query import CQLQuery

def validate_cql_response(raw: str) -> CQLQuery:
    try:
        cleaned = _extract_json_text(raw)
        data = json.loads(cleaned)
        return CQLQuery.model_validate(data)
    except Exception as e:
        raise RuntimeError(f"CQL schema validation failed: {e}")
```

This plugs straight into your retry mechanism if you want it.

---

## 4ï¸âƒ£ Extend your existing search tool (no breaking changes)

ğŸ“ **`tool_utils/confluence_search.py`**

Add **ONE new function** at the bottom:

```python
def search_confluence_by_cql(cql: str, limit: int = 10) -> List[PageSearchResult]:
    endpoint = f"{CONFLUENCE_BASE_URL}/rest/api/content/search"
    params = {
        "cql": cql,
        "limit": limit,
        "expand": "space"
    }

    req = PreparedRequest()
    req.prepare_url(endpoint, params)

    client = create_rest_client()

    try:
        resp = client.get(req.url)
    except Exception:
        return []

    if not isinstance(resp, dict):
        return []

    results = []
    for page in resp.get("results", []):
        title = page.get("title", "")
        space_key = page.get("space", {}).get("key", "")
        page_id = page.get("id")

        url = ""
        if title and space_key:
            url = f"{CONFLUENCE_BASE_URL}/display/{space_key}/{quote_plus(title)}"

        results.append(PageSearchResult(title, space_key, url, page_id))

    return results
```

âœ… No existing code touched
âœ… Your original `search_confluence_pages()` still works
âœ… New function supports agent-generated CQL

---

## 5ï¸âƒ£ Orchestrator (small, clean, optional file)

ğŸ“ **`main.py` (or new `pipeline.py`)**

```python
from confluence_agent.confluence_agents import (
    create_confluence_agent,
    create_cql_builder_agent,
)
from validation.response_guard import (
    validate_agent_response,
    validate_cql_response,
)

async def run_confluence_with_cql(user_query: str):
    cql_agent = create_cql_builder_agent()
    exec_agent = create_confluence_agent()

    # 1ï¸âƒ£ Build CQL
    cql_result = await cql_agent.run(task=user_query)
    cql_query = validate_cql_response(cql_result.messages[-1].content)

    # 2ï¸âƒ£ Execute using existing agent
    task = f"""
    Use the following CQL query to search Confluence and answer the user.

    CQL: {cql_query.cql}
    Limit: {cql_query.limit}
    """

    result = await exec_agent.run(task=task)
    return validate_agent_response(result.messages[-1].content)
```

---

## ğŸ§  Why this merge is safe

âœ” No refactors
âœ” No breaking API changes
âœ” Uses your validation philosophy
âœ” Clear agent responsibility boundaries
âœ” Easy to debug (inspect CQL separately)

---

## ğŸ”¥ What you now have

* **Agent 1** â†’ understands *intent â†’ CQL*
* **Agent 2** â†’ executes *CQL â†’ knowledge*
* Strong schema enforcement
* Enterprise-grade traceability

---

If you want, next I can:

* Add **retry-with-feedback** for bad CQL
* Teach the CQL agent about **labels, spaces, recency**
* Add **unit tests** for CQL quality
* Help you convert this into an MCP server

Just tell me ğŸ‘Œ
