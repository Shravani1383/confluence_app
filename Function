import asyncio
from typing import Sequence
from fastapi import FastAPI, Query
from backend.integrations.rest_client import RestClient  # ✅ Use your existing RestClient
from backend.core.config import (
    ALM_CONFLUENCE_BASE_URL,
    WPB_CONFLUENCE_BASE_URL,
    DOMAIN_USER,
    DOMAIN_PASSWORD,
    proxies,
)
from backend.core.cert_config import CERT_FILE

# ============================================================
# CLIENT CLASS (Reuses same name / interface)
# ============================================================

class ConfluenceClient:
    """Singleton Confluence client using internal RestClient."""

    _instance = None
    _init_args = None

    def __init__(self, user, password, proxies=None, cert_file=None):
        # ✅ Use your in-house RestClient for auth, SSL, proxy handling
        self.rest_client = RestClient(
            credentials=(user, password),
            proxies=proxies,
            cert_file=cert_file,
        )

    @classmethod
    def get_instance(cls, user, password, proxies=None, cert_file=None):
        args = (user, password, proxies, cert_file)
        if cls._instance is None or cls._init_args != args:
            cls._instance = cls(user, password, proxies, cert_file)
            cls._init_args = args
        return cls._instance

    async def async_search_pages(self, base_url: str, cql: str, limit: int = 10) -> dict:
        """
        Perform async search using your RestClient.get()
        This wraps the sync call inside a thread for FastAPI compatibility.
        """
        endpoint = f"{base_url.rstrip('/')}/rest/api/content/search"
        params = {"cql": cql, "limit": limit}

        print(f"[DEBUG] Hitting endpoint: {endpoint}")
        try:
            # ✅ Run sync call asynchronously (non-blocking)
            response = await asyncio.to_thread(
                lambda: self.rest_client.get(endpoint, params=params)
            )
            return response
        except Exception as e:
            print(f"[ERROR] Confluence search failed for {base_url}: {e}")
            return {"error": str(e), "url": endpoint}


# ============================================================
# LOGIC (Reuses your function names exactly)
# ============================================================

def build_cql(keywords: Sequence[str]) -> str:
    """Construct a CQL query that matches any provided keyword."""
    words = []
    for kw in keywords:
        if kw:
            words.extend(kw.split())

    parts = [f'(text ~ "{word}")' for word in words]
    return " OR ".join(parts)


async def fetch_confluence_search_async(
    keywords: list[str],
    max_results: int = 10,
    source: str = "alm"
) -> dict:
    """
    Perform async Confluence search using ConfluenceClient.
    Supports 'alm', 'wpb', or 'both'.
    """
    cql = build_cql(keywords)
    print(f"[DEBUG] [ASYNC] CQL Query: {cql}")

    client = ConfluenceClient.get_instance(
        DOMAIN_USER,
        DOMAIN_PASSWORD,
        proxies=proxies,
        cert_file=CERT_FILE
    )

    results = {}

    async def search_alm():
        print("[DEBUG] Querying ALM Confluence...")
        return await client.async_search_pages(ALM_CONFLUENCE_BASE_URL, cql, limit=max_results)

    async def search_wpb():
        print("[DEBUG] Querying WPB Confluence...")
        return await client.async_search_pages(WPB_CONFLUENCE_BASE_URL, cql, limit=max_results)

    if source == "both":
        alm_result, wpb_result = await asyncio.gather(search_alm(), search_wpb())
        results["alm"] = alm_result
        results["wpb"] = wpb_result
    elif source == "alm":
        results["alm"] = await search_alm()
    elif source == "wpb":
        results["wpb"] = await search_wpb()
    else:
        raise ValueError("source must be one of ['alm', 'wpb', 'both']")

    return results


# ============================================================
# FASTAPI APP
# ============================================================

app = FastAPI(title="HSBC Confluence Search API", version="1.0")


@app.get("/api/search")
async def search_confluence(
    query: str = Query(..., description="Search keywords (space-separated)"),
    limit: int = Query(10, description="Max number of results per source"),
    source: str = Query("both", enum=["alm", "wpb", "both"])
):
    """Perform async search across ALM/WPB Confluence instances."""
    keywords = query.split()
    results = await fetch_confluence_search_async(keywords, max_results=limit, source=source)
    return {"query": query, "results": results}


# ============================================================
# MAIN ENTRY POINT
# ============================================================

if __name__ == "__main__":
    import uvicorn
    uvicorn.run("confluence_search_api:app", host="0.0.0.0", port=8000, reload=True)
