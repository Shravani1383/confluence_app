import asyncio
from typing import Sequence
from fastapi import FastAPI, Query
import aiohttp

# ============================================================
# CONFIG (Replace with your internal config imports)
# ============================================================

ALM_CONFLUENCE_BASE_URL = "https://alm-confluence.systems.uk.hsbc/confluence"
WPB_CONFLUENCE_BASE_URL = "https://wpb-confluence.systems.uk.hsbc/"
DOMAIN_USER = "your_domain_user"
DOMAIN_PASSWORD = "your_domain_password"
CERT_FILE = None
proxies = None

# ============================================================
# CLIENT CLASS (Reuses same name / interface)
# ============================================================

class ConfluenceClient:
    """Singleton async Confluence client."""

    _instance = None
    _init_args = None

    def __init__(self, user, password, proxies=None, cert_file=None):
        # Stub: replace this with your RestClient auth logic
        self.credentials = (user, password)
        self.proxies = proxies
        self.cert_file = cert_file

    @classmethod
    def get_instance(cls, user, password, proxies=None, cert_file=None):
        args = (user, password, proxies, cert_file)
        if cls._instance is None or cls._init_args != args:
            cls._instance = cls(user, password, proxies, cert_file)
            cls._init_args = args
        return cls._instance

    async def async_search_pages(self, base_url: str, cql: str, limit: int = 10) -> dict:
        """Perform async search via Confluence REST API."""
        endpoint = f"{base_url.rstrip('/')}/rest/api/content/search"
        params = {"cql": cql, "limit": limit}
        print(f"[DEBUG] Hitting endpoint: {endpoint}")

        auth = aiohttp.BasicAuth(*self.credentials)

        try:
            async with aiohttp.ClientSession(auth=auth) as session:
                async with session.get(endpoint, params=params, ssl=False) as resp:
                    if resp.status != 200:
                        return {
                            "error": f"{base_url} returned {resp.status}",
                            "details": await resp.text(),
                        }
                    return await resp.json()
        except Exception as e:
            return {"error": str(e), "url": endpoint}


# ============================================================
# LOGIC (Reuses your function names exactly)
# ============================================================

def build_cql(keywords: Sequence[str]) -> str:
    """Construct a CQL query that matches any provided keyword."""
    words = []
    for kw in keywords:
        if kw:
            words.extend(kw.split())

    parts = [f'(text ~ "{word}")' for word in words]
    return " OR ".join(parts)


async def fetch_confluence_search_async(
    keywords: list[str],
    max_results: int = 10,
    source: str = "alm"
) -> dict:
    """
    Perform async Confluence search using ConfluenceClient.
    Supports 'alm', 'wpb', or 'both'.
    """
    cql = build_cql(keywords)
    print(f"[DEBUG] [ASYNC] CQL Query: {cql}")

    client = ConfluenceClient.get_instance(
        DOMAIN_USER,
        DOMAIN_PASSWORD,
        proxies=proxies,
        cert_file=CERT_FILE
    )

    results = {}

    async def search_alm():
        print("[DEBUG] Querying ALM Confluence...")
        return await client.async_search_pages(ALM_CONFLUENCE_BASE_URL, cql, limit=max_results)

    async def search_wpb():
        print("[DEBUG] Querying WPB Confluence...")
        return await client.async_search_pages(WPB_CONFLUENCE_BASE_URL, cql, limit=max_results)

    if source == "both":
        alm_result, wpb_result = await asyncio.gather(search_alm(), search_wpb())
        results["alm"] = alm_result
        results["wpb"] = wpb_result
    elif source == "alm":
        results["alm"] = await search_alm()
    elif source == "wpb":
        results["wpb"] = await search_wpb()
    else:
        raise ValueError("source must be one of ['alm', 'wpb', 'both']")

    return results


# ============================================================
# FASTAPI APP
# ============================================================

app = FastAPI(title="HSBC Confluence Search API", version="1.0")


@app.get("/api/search")
async def search_confluence(
    query: str = Query(..., description="Search keywords (space-separated)"),
    limit: int = Query(10, description="Max number of results per source"),
    source: str = Query("both", enum=["alm", "wpb", "both"])
):
    """Perform async search across ALM/WPB Confluence instances."""
    keywords = query.split()
    results = await fetch_confluence_search_async(keywords, max_results=limit, source=source)
    return {"query": query, "results": results}


# ============================================================
# MAIN ENTRY POINT
# ============================================================

if __name__ == "__main__":
    import uvicorn
    uvicorn.run("confluence_search_api:app", host="0.0.0.0", port=8000, reload=True)
