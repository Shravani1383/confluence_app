"""
confluence_tool.py

Single-file Confluence content fetcher designed for:
- maintainability
- unit testing
- agentic AI tool usage
"""

from dataclasses import dataclass
from typing import List, Optional
from urllib.parse import urlparse, unquote
import re

from bs4 import BeautifulSoup


# ============================================================
# Models
# ============================================================

@dataclass
class ConfluencePageRef:
    base_url: str
    space_key: Optional[str]
    page_id: Optional[str]
    title: Optional[str]


@dataclass
class PageContent:
    page_id: str
    space_key: str
    title: str
    url: str
    plain_text_chunks: List[str]
    tables: List[List[List[str]]]


# ============================================================
# URL Parsing (PURE FUNCTIONS → EASY TO TEST)
# ============================================================

_SPACE_RE = re.compile(r"/spaces/(?P<space>[^/]+)/pages/(?P<id>\d+)")
_DISPLAY_RE = re.compile(r"/display/(?P<space>[^/]+)/(?P<title>[^/?#]+)")


def parse_confluence_url(url: str) -> ConfluencePageRef:
    if not isinstance(url, str):
        raise ValueError("URL must be a string")

    parsed = urlparse(url)
    base_url = f"{parsed.scheme}://{parsed.netloc}"
    path = parsed.path

    if m := _SPACE_RE.search(path):
        return ConfluencePageRef(
            base_url=base_url,
            space_key=m.group("space"),
            page_id=m.group("id"),
            title=None,
        )

    if m := _DISPLAY_RE.search(path):
        return ConfluencePageRef(
            base_url=base_url,
            space_key=m.group("space"),
            page_id=None,
            title=unquote(m.group("title").replace("+", " ")),
        )

    return ConfluencePageRef(base_url, None, None, None)


# ============================================================
# Endpoint Construction
# ============================================================

def build_content_endpoint(ref: ConfluencePageRef) -> str:
    if ref.page_id:
        return (
            f"{ref.base_url}/rest/api/content/{ref.page_id}"
            "?expand=body.storage,space,title"
        )

    if ref.space_key and ref.title:
        return (
            f"{ref.base_url}/rest/api/content"
            f"?spaceKey={ref.space_key}&title={ref.title}"
            "&expand=body.storage,space,title"
        )

    raise ValueError("Insufficient data to build Confluence endpoint")


def normalize_confluence_response(resp: dict) -> dict:
    if isinstance(resp, dict) and "results" in resp:
        return resp["results"][0] if resp["results"] else {}
    return resp


# ============================================================
# HTML Parsing → Structured Content
# ============================================================

def parse_page_html(page: dict, url: str) -> PageContent:
    html = page.get("body", {}).get("storage", {}).get("value", "")
    soup = BeautifulSoup(html, "html.parser")

    # Extract tables
    tables = []
    for table in soup.find_all("table"):
        table_rows = []
        for row in table.find_all("tr"):
            cells = [
                cell.get_text(" ", strip=True)
                for cell in row.find_all(["th", "td"])
            ]
            if cells:
                table_rows.append(cells)
        if table_rows:
            tables.append(table_rows)

    # Extract readable text
    text_chunks = [
        tag.get_text(" ", strip=True)
        for tag in soup.find_all(["p", "h1", "h2", "h3", "h4", "li"])
        if tag.get_text(strip=True)
    ]

    return PageContent(
        page_id=page.get("id", ""),
        space_key=page.get("space", {}).get("key", ""),
        title=page.get("title", ""),
        url=url,
        plain_text_chunks=text_chunks,
        tables=tables,
    )


# ============================================================
# Confluence Client Wrapper (EASY TO MOCK)
# ============================================================

class ConfluenceClient:
    def __init__(self, rest_client):
        self.rest_client = rest_client

    def get(self, endpoint: str) -> dict:
        response = self.rest_client.get(endpoint)
        if isinstance(response, dict) and "error" in response:
            raise RuntimeError(response["error"])
        return response


# ============================================================
# ORCHESTRATOR (AGENT TOOL ENTRYPOINT)
# ============================================================

def fetch_confluence_page_as_json(
    confluence_url: str,
    rest_client,
) -> dict:
    """
    Agent-facing tool:
    - Input: Confluence URL
    - Output: Structured JSON optimized for LLM + vector DB usage
    """

    # 1. Parse URL
    ref = parse_confluence_url(confluence_url)

    # 2. Build endpoint
    endpoint = build_content_endpoint(ref)

    # 3. Fetch data
    client = ConfluenceClient(rest_client)
    raw = client.get(endpoint)

    # 4. Normalize API response
    page = normalize_confluence_response(raw)

    # 5. Parse HTML
    content = parse_page_html(page, confluence_url)

    return content.__dict__
