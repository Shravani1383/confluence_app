You are a Confluence search intelligence engine.

Your task is to analyze a user's natural-language query and extract structured information 
to help build a highly relevant search query for Confluence.

You must:
1. Identify the **intent** ‚Äî what the user is trying to achieve or find.
2. Extract meaningful **keywords** ‚Äî important entities, topics, tools, processes, or product names.
3. Suggest **semantically related terms** for each keyword that may appear in Confluence pages
   (e.g., "tool" ‚Üí ["tool", "platform", "portal", "system", "application", "dashboard"]).
4. Detect a specific **space or project** name (if explicitly mentioned, e.g., "in HR space", "in IT Confluence"), else set `"space": null`.
5. Capture **context** such as purpose, department, or domain when possible.
6. Output only valid JSON ‚Äî no text before or after.

Example:

User query: 
"Can you find the documentation for the new employee onboarding process in HR?"

Your output:
{
  "intent": "find documentation related to HR onboarding process",
  "keywords": ["employee onboarding", "HR", "documentation"],
  "semantic_expansions": {
    "employee onboarding": ["employee onboarding", "new hire process", "joining process", "induction", "orientation"],
    "HR": ["HR", "human resources", "people operations"],
    "documentation": ["documentation", "guide", "manual", "wiki page", "knowledge base"]
  },
  "space": "HR",
  "context": {
    "purpose": "process reference",
    "domain": "employee onboarding"
  }
}

Now process this user query:
"{user_query}"


def build_cql(llm_output: dict) -> str:
    """
    Build a Confluence CQL string using intent, keywords, and semantic expansions.
    Example:
      (text ~ "tool" OR text ~ "platform") AND (text ~ "quantum")
    """

    keywords = llm_output.get("keywords", [])
    expansions = llm_output.get("semantic_expansions", {})
    space = llm_output.get("space")
    clauses = []

    for kw in keywords:
        expanded_terms = expansions.get(kw.lower(), [kw])
        clause = " OR ".join([f'text ~ "{term}"' for term in expanded_terms])
        clauses.append(f"({clause})")

    # Combine with AND between main keywords
    cql_query = " AND ".join(clauses)

    # Add space filter if present
    if space:
        cql_query = f"space = \"{space}\" AND {cql_query}"

    # Optional: restrict to pages (exclude attachments/comments)
    cql_query = f"type = page AND ({cql_query})"

    return cql_query



Absolutely ‚Äî **you are 100% correct**.
If the keyword is a **proper noun** (software name, product name, team name, place name, acronym, code name),
then **semantic expansion is harmful** because:

* ‚ÄúKubernetes‚Äù ‚â† ‚Äúcontainer system‚Äù
* ‚ÄúJira‚Äù ‚â† ‚Äúissue platform‚Äù
* ‚ÄúHTI Innovation Pod‚Äù ‚â† ‚Äúinnovation portal‚Äù
* ‚ÄúQuantumX‚Äù ‚â† ‚Äúlearning tool‚Äù
* ‚ÄúDataLake360‚Äù ‚â† ‚Äústorage platform‚Äù

These must be treated as **literal identifiers**, not expanded.

So we need to modify the prompt so the LLM:

‚úÖ **Detects proper nouns / named entities**
‚úÖ **Does NOT expand them semantically**
‚úÖ **Only expands general concepts like ‚Äúaccess‚Äù, ‚Äútool‚Äù, ‚Äúprocess‚Äù, ‚Äúlearning‚Äù, ‚Äúdocumentation‚Äù**
‚úÖ **Produces clean keywords + semantic expansions only where useful**

---

# ‚úÖ **Final Improved Prompt (with Noun/Proper-Noun Protection)**

This is the production-quality version:

---

```
You are a Confluence search intelligence engine.

Your task is to analyze a user's natural-language query and extract structured
information to build a relevant Confluence CQL query.

Rules:

1. Identify the **intent** (short description of what the user is trying to find).
2. Extract meaningful **keywords**.
   - Include core concepts (e.g., "access", "onboarding", "documentation").
   - Include named software, tools, project names, platforms, acronyms,
     technologies, product names, and team names AS-IS.
3. For each keyword, determine if it is:
   - a **general concept** ‚Üí expand semantically,
   - a **proper noun / named entity** ‚Üí DO NOT expand semantically.
4. Proper nouns include:
   - software names (e.g., ‚ÄúKubernetes‚Äù, ‚ÄúSalesforce‚Äù, ‚ÄúJira‚Äù)
   - internal tools (e.g., ‚ÄúHTI Innovation Pod‚Äù, ‚ÄúQuantumX Portal‚Äù)
   - project names (e.g., ‚ÄúApollo Program‚Äù)
   - places/teams (e.g., ‚ÄúHR‚Äù, ‚ÄúFinance‚Äù, ‚ÄúData Engineering‚Äù)
   - abbreviations & acronyms (e.g., ‚ÄúSSO‚Äù, ‚ÄúAML‚Äù, ‚ÄúKYC‚Äù)
   When a keyword is a proper noun, its semantic_expansion list must contain only itself.
5. Detect if the query clearly mentions a Confluence space (e.g. ‚Äúin HR space‚Äù).
   Otherwise set `"space": null`.
6. Extract additional **context** when possible (purpose, domain).
7. Output **only** valid JSON.

Example (generalized):

User query:
"Where can I find documentation for Kubernetes deployment in DevOps?"

Output:
{
  "intent": "find Kubernetes deployment documentation",
  "keywords": ["Kubernetes", "deployment", "documentation", "DevOps"],
  "semantic_expansions": {
    "Kubernetes": ["Kubernetes"],
    "deployment": ["deployment", "setup", "configuration", "installation"],
    "documentation": ["documentation", "guide", "manual", "runbook", "wiki"],
    "DevOps": ["DevOps"]
  },
  "space": "DevOps",
  "context": {
    "purpose": "technical reference",
    "domain": "Kubernetes deployment"
  }
}

Now process this user query:
"{user_query}"
```

---

# ‚úÖ Updated `build_cql()` (Works with Nouns vs Concepts)

This function takes the LLM output and builds a correct CQL.

```python
def build_cql(llm_output: dict) -> str:
    """
    Build a Confluence CQL string using extracted keywords
    and semantic expansions. Proper nouns have no expansions.
    """
    keywords = llm_output.get("keywords", [])
    expansions = llm_output.get("semantic_expansions", {})
    space = llm_output.get("space")

    clauses = []

    for kw in keywords:
        terms = expansions.get(kw, [kw])  # If no expansion, use as-is
        sub_clause = " OR ".join([
            f'title ~ "{term}" OR text ~ "{term}"' for term in terms
        ])
        clauses.append(f"({sub_clause})")

    # Combine all keyword groups with AND
    cql_query = " AND ".join(clauses)

    # Add space filter
    if space:
        cql_query = f'space = "{space}" AND {cql_query}'

    # Restrict to pages
    return f"type = page AND ({cql_query})"
```

---

# ‚úÖ Example Behavior

### Input Query:

> ‚ÄúFind the guide for deploying Apache Kafka in our cloud environment.‚Äù

### LLM Output (expected):

```json
{
  "intent": "find Apache Kafka deployment guide",
  "keywords": ["Apache Kafka", "deployment", "guide", "cloud"],
  "semantic_expansions": {
    "Apache Kafka": ["Apache Kafka"],
    "deployment": ["deployment", "setup", "installation", "configuration"],
    "guide": ["guide", "documentation", "manual", "runbook"],
    "cloud": ["cloud", "cloud environment", "infrastructure"]
  },
  "space": null,
  "context": {
    "purpose": "technical instructions",
    "domain": "Apache Kafka"
  }
}
```

### Resulting CQL:

```
type = page AND (
    (title ~ "Apache Kafka" OR text ~ "Apache Kafka") AND
    (title ~ "deployment" OR text ~ "deployment" OR
     title ~ "setup" OR text ~ "setup" OR
     title ~ "installation" OR text ~ "installation" OR
     title ~ "configuration" OR text ~ "configuration") AND
    (title ~ "guide" OR text ~ "guide" OR
     title ~ "documentation" OR text ~ "documentation" OR
     title ~ "manual" OR text ~ "manual" OR
     title ~ "runbook" OR text ~ "runbook") AND
    (title ~ "cloud" OR text ~ "cloud" OR
     title ~ "cloud environment" OR text ~ "cloud environment" OR
     title ~ "infrastructure" OR text ~ "infrastructure")
)
```

---

# ‚úÖ Why This Version Works Perfectly

‚úÖ Protects **technology names**, **tool names**, **product names**
‚úÖ Expands only **general concepts**
‚úÖ Prevents irrelevant expansions
‚úÖ Produces highly robust CQL
‚úÖ Works across *all possible topics*
‚úÖ Works across *all companies & org structures*
‚úÖ Best balance of **precision + flexibility**

---

If you want, I can also give you:

‚úÖ The **semantic re-ranking module** (takes Confluence API results ‚Üí embeds ‚Üí ranks)
‚úÖ A **Confluence retriever pipeline** integrating all this
‚úÖ A **confidence score system** to decide between fallback or answer

Just tell me which one you want next.


You are an intent extraction assistant.
Extract keywords that capture the full context of the user's query.
Use as few words as possible, but enough to cover all major aspects of the query.
Preserve specific nouns (technologies, places, product names).
Do not add synonyms or expand the meaning.

Example:
Q: How to deploy an ML model using Docker on Kubernetes with GPU?
A: ml model docker kubernetes gpu deployment


def build_cql(keywords: list[str], max_terms: int = 8) -> str:
    keywords = keywords[:max_terms]
    text_filters = [f'text ~ "{kw}"' for kw in keywords]
    cql = f'type = "page" AND ({" OR ".join(text_filters)})'
    return cql






Perfect ‚Äî that‚Äôs exactly the right direction. üëè

You‚Äôre thinking like a designer of a *production-grade* retrieval layer ‚Äî ensuring both **consistent parsing** and **logical query scoping** (only searching in specific Confluence spaces when intended).

Let‚Äôs build a **precise and reliable prompt** and the **corresponding build_cql() function**.

---

## üß† Intent Extraction Prompt (Finalized)

Here‚Äôs a **robust and general-purpose** prompt for extracting clean, Confluence-ready keywords:

---

**Prompt:**

```
You are an intent extraction assistant for a Confluence search system.

Your task:
1. Analyze the user's query and extract the core keywords that best represent the user's intent.
2. Include only essential words that capture what the user is actually looking for.
3. Preserve specific nouns (like product names, software tools, frameworks, or places) exactly as written.
4. Do NOT add synonyms or rephrase.
5. Use as few words as possible while keeping full context.
6. Include the Confluence space name ONLY if it is explicitly mentioned in the user query.
7. Do NOT include common filler words like "how", "can", "the", "is", etc.
8. Output must be in the following JSON format:
   {
     "keywords": ["word1", "word2", "word3"],
     "space": "SPACE_NAME or null"
   }

Examples:
Q: "How to integrate Jira with Confluence?"
A: {"keywords": ["integrate", "jira", "confluence"], "space": null}

Q: "Show pages related to network issues in IT Support space"
A: {"keywords": ["network", "issues"], "space": "IT Support"}

Q: "Troubleshooting ML model deployment"
A: {"keywords": ["ml", "model", "deployment"], "space": null}
```

---

## üß© Python Function: `build_cql()`

Now, we‚Äôll construct the **CQL query** dynamically based on these extracted keywords and optional space.

```python
def build_cql(intent: dict, max_terms: int = 8) -> str:
    """
    Build a Confluence CQL query from extracted intent.
    intent = {"keywords": [...], "space": "..." or None}
    """
    keywords = intent.get("keywords", [])[:max_terms]
    space = intent.get("space")

    # Build text query for keywords
    text_filters = [f'text ~ "{kw}"' for kw in keywords]
    query = f'type = "page" AND ({" OR ".join(text_filters)})'

    # Add space filter if explicitly mentioned
    if space:
        query += f' AND space = "{space}"'

    return query
```

---

## ‚úÖ Example

```python
intent = {
  "keywords": ["jira", "integration", "confluence"],
  "space": None
}
print(build_cql(intent))
```

**Output:**

```
type = "page" AND (text ~ "jira" OR text ~ "integration" OR text ~ "confluence")
```

If the user said ‚Äúin IT Support space‚Äù, then:

```
type = "page" AND (text ~ "network" OR text ~ "issues") AND space = "IT Support"
```

---

This design gives you:

* üéØ Deterministic output structure
* ‚ö° Reliable downstream parsing
* üß© Optional scoping to specific spaces
* üîç Flexible keyword count while maintaining precision

---

Would you like me to extend this so it can **auto-fallback to semantic similarity** (e.g., via embeddings) when Confluence search gives too few results? That would make it production-ready.
